#pragma config(Sensor, in1,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  encRight,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encLeft,        sensorQuadEncoder)
#pragma config(Sensor, dgtl12, test,           sensorRotation)
#pragma config(Motor,  port1,           leftBack,      tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftFront,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           leftTower,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightTower,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rightFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          rightBack,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define abs(X) ((X < 0) ? -1 * X : X)

void forward(int distance) {
	SensorValue[encLeft] = 0;
	SensorValue[encRight] = 0;
	int tickGoal = distance * 28;
	bool done = false;
	while(abs(SensorValue[encRight]) < tickGoal) //Forward for 5 rotations
	{
		if(SensorValue[encLeft] < SensorValue[encRight])
		{
			motor[leftFront] = 50;
			motor[leftBack] = 50;
			motor[rightFront] = 63;
			motor[rightBack] = -63;
		}
		if(SensorValue[encLeft] > SensorValue[encRight])
		{
			motor[leftFront] = 63;
			motor[leftBack] = 63;
			motor[rightFront] = 50;
			motor[rightBack] = -50;
		}
		if(SensorValue[encLeft] == SensorValue[encRight])
		{
			motor[leftFront] = 63;
			motor[leftBack] = 63;
			motor[rightFront] = 63;
			motor[rightBack] = -63;		}
	}
}

void backwards(int distance) {
	SensorValue[encLeft] = 0;
	SensorValue[encRight] = 0;
	int tickGoal = distance * 28;
	bool done = false;
	while(abs(SensorValue[encRight]) < tickGoal) //Forward for 5 rotations
	{
		if(SensorValue[encLeft] < SensorValue[encRight])
		{
			motor[leftFront] = -50;
			motor[leftBack] = -50;
			motor[rightFront] = -63;
			motor[rightBack] = 63;
		}
		if(SensorValue[encLeft] > SensorValue[encRight])
		{
			motor[leftFront] = -63;
			motor[leftBack] = -63;
			motor[rightFront] = -50;
			motor[rightBack] = 50;
		}
		if(SensorValue[encLeft] == SensorValue[encRight])
		{
			motor[leftFront] = -63;
			motor[leftBack] = -63;
			motor[rightFront] = -63;
			motor[rightBack] = 63;		}
	}
}

void turnLeft(int degrees) {
	SensorValue[encLeft] = 0;
	SensorValue[encRight] = 0;
	while(SensorValue[encRight] < degrees || SensorValue[encLeft] > -degrees) {
		if(abs(SensorValue[encRight]) < degrees) {
			motor[rightFront] = 63;
			motor[rightBack] = -63;
			} else {
			motor[rightFront] = 0;
			motor[rightBack] = 0;
		}
		if(abs(SensorValue[encLeft]) < degrees){
			motor[leftFront] = -63;
			motor[leftBack] = -63;
			} else {
			motor[leftFront] = 0;
			motor[leftBack] = 0;
		}
	}
}

void turnRight(int degrees) {
	SensorValue[encLeft] = 0;
	SensorValue[encRight] = 0;
	while(SensorValue[encRight] < degrees || SensorValue[encLeft] > -degrees) {
		if(abs(SensorValue[encLeft]) < degrees) {
			motor[leftFront] = 63;
			motor[leftBack] = 63;
			} else {
			motor[leftFront] = 0;
			motor[leftBack] = 0;
		}
		if(SensorValue[encRight] < degrees){
			motor[rightFront] = -63;
			motor[rightBack] = 63;
			} else {
			motor[rightFront] = 0;
			motor[rightBack] = 0;
		}
	}
}
task main()
{
	bool notClosedCube = true;
	bool notLiftPickup = true;
	int pickupCounter = 0;
	turnRight(120);
		motor[leftFront] = 0;
	motor[leftBack] = 0;
	motor[rightFront] = 0;
	motor[rightBack] = 0;
	wait1Msec(500);
	while (SensorValue[liftPot] < 600) {
		motor[leftTower] = 20;
		motor[rightTower] = 20;
	}
	motor[claw] = 0;
	wait1Msec(100);
	while (SensorValue[clawPot] < 3100) {
		motor[claw] = -80;
	}
	motor[claw] = 0;
	wait1Msec(100);
	while (SensorValue[clawPot] > 2500) {
		motor[claw] = 20;
	}
	motor[claw] = 0;
	wait1Msec(100);
	forward(50);
	motor[leftFront] = 0;
	motor[leftBack] = 0;
	motor[rightFront] = 0;
	motor[rightBack] = 0;
	turnRight(425);
	motor[leftFront] = 0;
	motor[leftBack] = 0;
	motor[rightFront] = 0;
	motor[rightBack] = 0;
	wait1Msec(100);
	while (SensorValue[liftPot] > 0) {
		motor[leftTower] = -30;
		motor[rightTower] = -30;
	}
	motor[leftTower] = 0;
	motor[rightTower] = 0;
	wait1Msec(100);
	while(notLiftPickup) {
		if (SensorValue[clawPot] < 3100 && notClosedCube) {
			motor[claw] = -80;
			if (SensorValue[clawPot] >= 2850) {
				notClosedCube = false;
				motor[claw] = -10;
				wait1Msec(500);
			}
		}
		if (SensorValue[liftPot] < 600 && !notClosedCube && notLiftPickup) {
			motor[leftTower] = 20;
			motor[rightTower] = 20;
			pickupCounter++;
			if (pickupCounter > 300) {
				notLiftPickup = false;
				motor[leftTower] = 5;
				motor[rightTower] = 5;
			}
			if (SensorValue[liftPot] >= 600) {
				notLiftPickup = false;
				motor[leftTower] = 0;
				motor[rightTower] = 0;
			}
		}
	}
	motor[claw] = -10;
}
